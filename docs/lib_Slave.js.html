<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/Slave.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module-DistIO_Master-Master.html">Master</a><ul class='methods'><li data-type='method'><a href="module-DistIO_Master-Master.html#broadcast">broadcast</a></li><li data-type='method'><a href="module-DistIO_Master-Master.html#close">close</a></li><li data-type='method'><a href="module-DistIO_Master-Master.html#createParallel">createParallel</a></li><li data-type='method'><a href="module-DistIO_Master-Master.html#createPipeline">createPipeline</a></li><li data-type='method'><a href="module-DistIO_Master-Master.html#createScatter">createScatter</a></li><li data-type='method'><a href="module-DistIO_Master-Master.html#createSlave">createSlave</a></li><li data-type='method'><a href="module-DistIO_Master-Master.html#createSlaves">createSlaves</a></li><li data-type='method'><a href="module-DistIO_Master-Master.html#createWorkpool">createWorkpool</a></li><li data-type='method'><a href="module-DistIO_Master-Master.html#getSlavesWithPath">getSlavesWithPath</a></li><li data-type='method'><a href="module-DistIO_Master-Master.html#getSlaveWithAlias">getSlaveWithAlias</a></li><li data-type='method'><a href="module-DistIO_Master-Master.html#getSlaveWithId">getSlaveWithId</a></li><li data-type='method'><a href="module-DistIO_Master-Master.html#kill">kill</a></li><li data-type='method'><a href="module-DistIO_Master-Master.html#shutdown">shutdown</a></li><li data-type='method'><a href="module-DistIO_Master-Master.html#slave">slave</a></li><li data-type='method'><a href="module-DistIO_Master-Master.html#slaveBelongsToGroup">slaveBelongsToGroup</a></li><li data-type='method'><a href="module-DistIO_Master-Master.html#tellSlave">tellSlave</a></li></ul></li><li><a href="module-DistIO_Request-Request.html">Request</a><ul class='methods'><li data-type='method'><a href="module-DistIO_Request-Request.html#clearTimeout">clearTimeout</a></li><li data-type='method'><a href="module-DistIO_Request-Request.html#hasTimedout">hasTimedout</a></li><li data-type='method'><a href="module-DistIO_Request-Request.html#onTimeout">onTimeout</a></li><li data-type='method'><a href="module-DistIO_Request-Request.html#send">send</a></li></ul></li><li><a href="module-DistIO_ResponseError-ResponseError.html">ResponseError</a></li><li><a href="module-DistIO_Response-Response.html">Response</a><ul class='methods'><li data-type='method'><a href="module-DistIO_Response-Response.html#pipe">pipe</a></li><li data-type='method'><a href="module-DistIO_Response-Response.html#toString">toString</a></li></ul></li><li><a href="module-DistIO_Response-ResponseArray.html">ResponseArray</a><ul class='methods'><li data-type='method'><a href="module-DistIO_Response-ResponseArray.html#each">each</a></li><li data-type='method'><a href="module-DistIO_Response-ResponseArray.html#joinValues">joinValues</a></li><li data-type='method'><a href="module-DistIO_Response-ResponseArray.html#push">push</a></li><li data-type='method'><a href="module-DistIO_Response-ResponseArray.html#sortBy">sortBy</a></li><li data-type='method'><a href="module-DistIO_Response-ResponseArray.html#unshift">unshift</a></li></ul></li><li><a href="module-DistIO_Response-SlaveArray.html">SlaveArray</a><ul class='methods'><li data-type='method'><a href="module-DistIO_Response-SlaveArray.html#close">close</a></li><li data-type='method'><a href="module-DistIO_Response-SlaveArray.html#do">do</a></li><li data-type='method'><a href="module-DistIO_Response-SlaveArray.html#each">each</a></li><li data-type='method'><a href="module-DistIO_Response-SlaveArray.html#exec">exec</a></li><li data-type='method'><a href="module-DistIO_Response-SlaveArray.html#exit">exit</a></li><li data-type='method'><a href="module-DistIO_Response-SlaveArray.html#kill">kill</a></li><li data-type='method'><a href="module-DistIO_Response-SlaveArray.html#push">push</a></li><li data-type='method'><a href="module-DistIO_Response-SlaveArray.html#shutdown">shutdown</a></li><li data-type='method'><a href="module-DistIO_Response-SlaveArray.html#then">then</a></li><li data-type='method'><a href="module-DistIO_Response-SlaveArray.html#unshift">unshift</a></li></ul></li><li><a href="module-DistIO_SlaveChildProcess-SlaveChildProcess.html">SlaveChildProcess</a><ul class='methods'><li data-type='method'><a href="module-DistIO_SlaveChildProcess-SlaveChildProcess.html#.isMasterMessage">isMasterMessage</a></li><li data-type='method'><a href="module-DistIO_SlaveChildProcess-SlaveChildProcess.html#invokeTaskListener">invokeTaskListener</a></li><li data-type='method'><a href="module-DistIO_SlaveChildProcess-SlaveChildProcess.html#task">task</a></li></ul></li><li><a href="module-DistIO_Slave-Slave.html">Slave</a><ul class='methods'><li data-type='method'><a href="module-DistIO_Slave-Slave.html#.getAllBusySlaves">getAllBusySlaves</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#.getAllIdleSlaves">getAllIdleSlaves</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#.getAllSlaves">getAllSlaves</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#.getLeastBusy">getLeastBusy</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#.getSlave">getSlave</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#.getSlavesInGroup">getSlavesInGroup</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#.getSlavesWithPath">getSlavesWithPath</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#.getSlaveWithAlias">getSlaveWithAlias</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#.getSlaveWithId">getSlaveWithId</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#ack">ack</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#close">close</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#do">do</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#exec">exec</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#exit">exit</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#kill">kill</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#noop">noop</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#shutdown">shutdown</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#then">then</a></li><li data-type='method'><a href="module-DistIO_Slave-Slave.html#toString">toString</a></li></ul></li><li><a href="module-DistIO_TimeoutResponse-TimeoutResponse.html">TimeoutResponse</a></li><li><a href="module-DistIO-DistIO.html">DistIO</a></li><li><a href="module-Workpool-Workpool.html">Workpool</a><ul class='methods'><li data-type='method'><a href="module-Workpool-Workpool.html#addTask">addTask</a></li><li data-type='method'><a href="module-Workpool-Workpool.html#addWhileTask">addWhileTask</a></li><li data-type='method'><a href="module-Workpool-Workpool.html#do">do</a></li><li data-type='method'><a href="module-Workpool-Workpool.html#nextSlave">nextSlave</a></li><li data-type='method'><a href="module-Workpool-Workpool.html#tickTaskQueue">tickTaskQueue</a></li><li data-type='method'><a href="module-Workpool-Workpool.html#while">while</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-DistIO.html">DistIO</a></li><li><a href="module-DistIO_Commands.html">DistIO/Commands</a></li><li><a href="module-DistIO_Master.html">DistIO/Master</a><ul class='methods'><li data-type='method'><a href="module-DistIO_Master.html#~flattenSlaveList">flattenSlaveList</a></li><li data-type='method'><a href="module-DistIO_Master.html#~idleInList">idleInList</a></li><li data-type='method'><a href="module-DistIO_Master.html#~inGroup">inGroup</a></li><li data-type='method'><a href="module-DistIO_Master.html#~leastBusyInGroup">leastBusyInGroup</a></li><li data-type='method'><a href="module-DistIO_Master.html#~leastBusyInList">leastBusyInList</a></li><li data-type='method'><a href="module-DistIO_Master.html#~notInGroup">notInGroup</a></li><li data-type='method'><a href="module-DistIO_Master.html#~task">task</a></li><li data-type='method'><a href="module-DistIO_Master.html#~validateCommand">validateCommand</a></li></ul></li><li><a href="module-DistIO_Request.html">DistIO/Request</a></li><li><a href="module-DistIO_Response.html">DistIO/Response</a><ul class='methods'><li data-type='method'><a href="module-DistIO_Response.html#~validateArgumentsAreAllResponses">validateArgumentsAreAllResponses</a></li><li data-type='method'><a href="module-DistIO_Response.html#~validateArgumentsAreAllSlaves">validateArgumentsAreAllSlaves</a></li></ul></li><li><a href="module-DistIO_ResponseError.html">DistIO/ResponseError</a></li><li><a href="module-DistIO_Slave.html">DistIO/Slave</a><ul class='methods'><li data-type='method'><a href="module-DistIO_Slave.html#~canInteract">canInteract</a></li><li data-type='method'><a href="module-DistIO_Slave.html#~cleanupSlaveReferences">cleanupSlaveReferences</a></li><li data-type='method'><a href="module-DistIO_Slave.html#~initializeSlaveEventsWithSlaveAndChildProcess">initializeSlaveEventsWithSlaveAndChildProcess</a></li><li data-type='method'><a href="module-DistIO_Slave.html#~isSlaveExceptionMessage">isSlaveExceptionMessage</a></li><li data-type='method'><a href="module-DistIO_Slave.html#~isSlaveMessage">isSlaveMessage</a></li><li data-type='method'><a href="module-DistIO_Slave.html#~sendCommandMessageToChildWithMetadata">sendCommandMessageToChildWithMetadata</a></li><li data-type='method'><a href="module-DistIO_Slave.html#~slaveMessageListener">slaveMessageListener</a></li></ul></li><li><a href="module-DistIO_SlaveChildProcess.html">DistIO/SlaveChildProcess</a><ul class='methods'><li data-type='method'><a href="module-DistIO_SlaveChildProcess.html#~sendExceptionMessageToMaster">sendExceptionMessageToMaster</a></li><li data-type='method'><a href="module-DistIO_SlaveChildProcess.html#~sendMessageToMaster">sendMessageToMaster</a></li><li data-type='method'><a href="module-DistIO_SlaveChildProcess.html#~slaveMessageListener">slaveMessageListener</a></li></ul></li><li><a href="module-DistIO_TimeoutResponse.html">DistIO/TimeoutResponse</a></li><li><a href="module-Workpool.html">Workpool</a></li></ul><h3>Events</h3><ul><li><a href="module-DistIO_Slave.html#~event:closed">closed</a></li><li><a href="module-DistIO_Slave.html#~event:exited">exited</a></li><li><a href="module-DistIO_Slave.html#~event:killed">killed</a></li><li><a href="module-DistIO_Slave.html#~event:post-sent">post-sent</a></li><li><a href="module-DistIO_Slave.html#~event:pre-send">pre-send</a></li><li><a href="module-DistIO_Slave.html#~event:response">response</a></li><li><a href="module-DistIO_SlaveChildProcess.html#~event:sendingexception">sending exception</a></li><li><a href="module-DistIO_SlaveChildProcess.html#~event:sendingmessage">sending message</a></li><li><a href="module-DistIO_Slave.html#~event:shutting-down">shutting-down</a></li><li><a href="module-DistIO_Master.html#~event:slavecreated">slave created</a></li><li><a href="module-DistIO_SlaveChildProcess.html#~event:taskcompleted">task completed</a></li><li><a href="module-DistIO_SlaveChildProcess.html#~event:taskstarted">task started</a></li><li><a href="module-DistIO_Slave.html#~event:uncaughtException">uncaughtException</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-DistIO_Request-RequestProtected.html">RequestProtected</a></li><li><a href="module-DistIO_Slave-SlaveOptions.html">SlaveOptions</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">lib/Slave.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file
 * The Slave class. A representation of the slave on the "front end".
 * Spawns child processes using ChildProcess.fork.
 * @copyright © 2016 Jason James Pollman
 */

'use strict';

/**
 * @module DistIO/Slave
 */

const EventEmitter = require('events').EventEmitter;
const fork = require('child_process').fork;
const lib = require('proto-lib').get('_');
const fs = require('fs');
const path = require('path');

const Request = require('./Request');
const Response = require('./Response');
const TimeoutResponse = require('./TimeoutResponse');
const Commands = require('./Commands');
const SlaveArray = require('./SlaveArray');

/**
 * Store valid slave file paths to prevent fs.stat I/O on the same path multiple times.
 * Keyed by filename.
 * @type {Object&lt;Boolean>}
 */
const validPaths = {};

/**
 * Used by the Slave class to privatize properties.
 */
const settings = Symbol();

/**
 * The time, now.
 * @return {Array&lt;Number>} A process.hrtime tuple.
 */
const INIT = process.hrtime();

/**
 * A "secret time" that is used to verify that a message is indeed a slave message.
 * This will be added to each outgoing request, and a property of each incoming response.
 * @type {Number}
 */
const SECRET_NUMBER = INIT[0] * 1e9 + INIT[1];

/**
 * A "secret id" used to verify that a message is indeed a slave message.
 * This will be added to each outgoing request, and a property of each incoming response.
 * @type {String}
 */
const SECRET_ID = lib.string.randomString(50);

/**
 * An object of pending requests, keyed by Slave id.
 * @type {Object&lt;Object&lt;Request>>}
 */
const pendingRequests = {};

/**
 * Stores active slaves.
 * @type {Object}
 */
const slaves = {};

/**
 * An accumulator. Each time a new slave is created, it is assigned this number, then it increments.
 * @type {Number}
 */
let slaveIds = 0;

/**
 * Removes all in-file reference to this slave, and close it.
 * @param {Slave} slave The slave to "cleanup".
 * @return {undefined}
 */
function cleanupSlaveReferences(slave) {
  slave[settings].process.unref();
  slave[settings].exited = true;
  slave[settings].closed = true;
  delete slaves[slave.id];
  delete pendingRequests[slave.id];
}

/**
 * True if the message recieved is a "slave message", or one sent by a slave process.
 * @param {Object} m The message data.
 * @return {Boolean} True if the message is a slave message, false otherwise.
 */
function isSlaveMessage(m) {
  if (m[SECRET_ID] === SECRET_NUMBER &amp;&amp; m.sent &amp;&amp; m.title === 'SlaveIOResponse' &amp;&amp; typeof m.request === 'object') {
    if (typeof m.request.for === 'number'
      &amp;&amp; typeof m.request.rid === 'number'
      &amp;&amp; typeof m.request.command === 'string') {
      return true;
    }
  }
  return false;
}

/**
 * True if the message recieved is a "slave exception message", or one sent by a slave process.
 * @param {Object} m The message data.
 * @return {Boolean} True if the message is a slave exception message, false otherwise.
 */
function isSlaveExceptionMessage(m) {
  if (typeof m.sent === 'number'
    &amp;&amp; m.title === 'SlaveIOException'
    &amp;&amp; typeof m.error === 'object'
    &amp;&amp; typeof m.from === 'number'
  ) {
    return true;
  }
  return false;
}

/**
 * Determines if the slave can execute tasks. And used to check for shutdown conditions.
 * @param {Slave} slave The slave to deterine interactivity status.
 * @return {Boolean} True if the slave can interact, false otherwise.
 */
function canInteract(slave) {
  return !slave[settings].spawnError
    &amp;&amp; !slave[settings].exited
    &amp;&amp; !slave[settings].closed
    &amp;&amp; !slave[settings].rejectingRequests;
}

/**
 * Listens for messages received from the slave.
 * @param {*} m The message data.
 * @return {undefined}
 */
function slaveMessageListener(m) {
  if (typeof m === 'object') {
    if (isSlaveMessage(m)) {
      if (pendingRequests[m.request.for] &amp;&amp; pendingRequests[m.request.for][m.request.rid]) {
        const request = pendingRequests[m.request.for][m.request.rid];
        request.clearTimeout();
        // Create a new response object from the message.
        const response = new Response(m);
        // Remove the message from the pending queue.
        delete pendingRequests[m.request.for][m.request.rid];

        if (request.hasTimedout(response)) {
          // Ignore the message, no op...
        } else if (request.callback instanceof Function) {
          // Invoke the callback for the message.
          request.callback.call(response, response, request);
        }
      }
    } else if (isSlaveExceptionMessage(m)) {
      const e = new Error(m.error.message || 'Unknown error');
      e.stack = m.error.stack;
      e.name = m.error.name;
      if (slaves[m.from]) {
        /**
         * Emitted when a slave exception occurs.
         * @event uncaughtException
         * @argument {Error} The error emitted from the slave.
         */
        slaves[m.from].emit('uncaughtException', e);
        slaves[m.from][settings].onUncaughtException(e);
      }
    }
  }
}

/**
 * Sets up various event handlers for a newly created slave process.
 * @param {Slave} slave The Slave object to setup the event handler for.
 * @param {ChildProcess} child The actual child process associated with this slave.
 * @param {Object} options Options to initialize the slave with.
 * @return {undefined}
 */
function initializeSlaveEventsWithSlaveAndChildProcess(slave, child, options) {
  const setSlaveExitedToTrue = () => {
    cleanupSlaveReferences(slave);
  };

  child.on('message', slaveMessageListener);

  // If the child fails to spawn...
  child.on('error', function onSpawnError(e) { // eslint-disable-line prefer-arrow-callback
    child.removeListener('error', onSpawnError);
    slave[settings].spawnError = e;
    cleanupSlaveReferences(slave);

    // Call user onSpawnError function...
    if (options.onSpawnError instanceof Function) options.onSpawnError.call(slave, e);

    // Add a new generic error listener
    child.on('error', () => {
      cleanupSlaveReferences(slave);
      if (options.onError instanceof Function) options.onError.call(slave, e);
    });
  });

  // Set connected to false when the child closes, exits, or is disconnected.
  child.on('close', setSlaveExitedToTrue);
  child.on('exit', setSlaveExitedToTrue);
}

/**
 * Sends a message to the child process.
 * @param {String} command The "name" or "command" of the message.
 * @param {Slave} slave The slave object to send the message to.
 * @param {*} meta The message's metadata.
 * @param {*} data The message's data.
 * @param {Function} done The callback to invoke when the message response is received.
 * @return {undefined}
 */
function sendCommandMessageToChildWithMetadata(command, slave, meta, data, done) {
  let request;
  switch (command) {
    case Commands.EXIT:
      request = new Request(slave, Commands.EXIT, meta, data, SECRET_ID, SECRET_NUMBER, settings, done);
      break;

    case Commands.ACK:
      request = new Request(slave, Commands.ACK, meta, data, SECRET_ID, SECRET_NUMBER, settings, done);
      break;

    case Commands.NULL:
      request = new Request(slave, Commands.NULL, meta, data, SECRET_ID, SECRET_NUMBER, settings, done);
      break;

    default:
      request = new Request(slave, command, meta, data, SECRET_ID, SECRET_NUMBER, settings, done);
  }

  // If a timeout is set on the metadata, set a timeout handler...
  request.onTimeout(() => {
    // Remove the request from the pending heap...
    delete pendingRequests[slave.id][request.id];
    // Create a new Timeout response...
    const response = new TimeoutResponse(slave, request);
    request.callback.call(response, response, request);
  });

  // Add the request to the pending heap...
  if (!pendingRequests[slave.id]) pendingRequests[slave.id] = {};
  pendingRequests[slave.id][request.rid] = request;

  /**
   * Allows the user to intercept messages prior to sending.
   * @event pre-send
   * @argument {Request} request The request object to be sent
   */
  slave.emit('pre-send', request);

  // Send the message to the child...
  request.send();
  slave[settings].sent++;

  /**
   * Emitted just after sending the request to the slave object.
   * @event post-sent
   * @argument {Request} request The request object that was sent.
   */
  slave.emit('post-send', request);
}

/**
 * A slave abstraction object.
 * Represents the slave in the master process.
 * @extends EventEmitter
 * @constructor
 * @throws {ReferenceError} If the argument passed to the "file" parameter isn't a string.
 * @throws {TypeError} If the argument passed to the "file" parameter isn't a valid regular file,
 * or if fs.statSync threw an error trying to open it.
 */
class Slave extends EventEmitter {
  /**
   * Returns the slave with the given id.
   * @param {Number} id The id of the slave to retrieve.
   * @return {Slave} The slave with the provided it, if it exists.
   */
  static getSlaveWithId(id) {
    return slaves[id] || null;
  }

  /**
   * Returns the slaves with the given file path.
   * @param {String} fp The id of the slave to retrieve.
   * @return {SlaveArray&lt;Slave>} The slave with the provided path, if any exist.
   */
  static getSlavesWithPath(fp) {
    const slavesAtPath = new SlaveArray();
    if (typeof fp !== 'string') return slavesAtPath;

    fp = path.resolve(path.normalize(fp));

    slaves._.every(s => {
      if (s.location === fp) slavesAtPath.push(s);
      return true;
    });
    return slavesAtPath;
  }

  /**
   * Returns all the slaves in the given group.
   * @param {String} g The name of the group to get the slaves from.
   * @return {SlaveArray&lt;Slave>} An array of slaves belonging to the given group
   */
  static getSlavesInGroup(g) {
    const group = new SlaveArray();
    if (typeof g !== 'string') return group;

    slaves._.every((s) => {
      if (s.group === g) group.push(s);
      return true;
    });
    return group;
  }

  /**
   * Gets the slave with the given alias.
   * @param {String} alias The alias to lookup the slave with.
   * @return {Slave} The slave with the provided alias, if it exists.
   */
  static getSlaveWithAlias(alias) {
    if (typeof alias !== 'string') return null;

    return slaves._.any(slave => {
      if (alias === slave.alias) return slave;
      return undefined;
    }) || null;
  }

  /**
   * Attempts to get a slave first by checking to see if the given argument for parameter "idOrAliasOrSlave" is a
   * slave, then by attempting to get the slave by id, then alias.
   * @param {Slave|Number|String} idOrAliasOrSlave A slave, slave id, or slave alias.
   * @return {Slave|null} The slave, if it was resolved, null otherwise.
   */
  static getSlave(idOrAliasOrSlave) {
    if (!idOrAliasOrSlave &amp;&amp; idOrAliasOrSlave !== 0) return null;

    let s = idOrAliasOrSlave instanceof Slave
      ? idOrAliasOrSlave
      : Slave.getSlaveWithId(idOrAliasOrSlave);

    s = s instanceof Slave ? s : Slave.getSlaveWithAlias(idOrAliasOrSlave);

    return s || null;
  }

  /**
   * The last id assigned to a slave.
   * @return {Number} The last used slave id.
   */
  static get lastId() {
    return slaveIds;
  }

  /**
   * Returns a shallow copy of the slaves object as an array.
   * @return {Array&lt;Slaves>} All slaves.
   */
  static getAllSlaves() {
    return new SlaveArray(...slaves._.toArray());
  }

  /**
   * Returns all idle slaves.
   * @return {Array&lt;Slaves>} All idle slaves.
   */
  static getAllIdleSlaves() {
    return new SlaveArray(...slaves._.toArray().filter(s => s.isIdle));
  }

  /**
   * Returns all busy slaves.
   * @return {Array&lt;Slaves>} All busy slaves.
   */
  static getAllBusySlaves() {
    return new SlaveArray(...slaves._.toArray().filter(s => s.isBusy));
  }

  /**
   * Returns the least busy slave in the given list of slaves.
   * @return {Slave} The least busy slave.
   */
  static getLeastBusy(...slaveList) {
    if (slaveList.length === 0) return null;
    return slaveList._.min(s => (s instanceof Slave ? s.pendingRequests : Number.MAX_VALUE));
  }

  /**
   * Slave constructor.
   * @param {String} file The filepath to the slave js file.
   * @param {Object} opts Options to init the slave with.
   * @return {Slave} The current slave instance.
   */
  constructor(file, opts) {
    super();
    const options = typeof opts === 'object' ? opts : {};

    if (!file || typeof file !== 'string') {
      throw new TypeError(
        'Slave constructor argument #0 requires a non-empty string, but got: ' +
        `"${typeof file === 'string' ? '' : typeof file}"`
      );
    }

    file = path.resolve(path.normalize(file));

    // Do some checking on the spawn file.
    // This might save some problems later.
    // The results are cached per file, to prevent subsequent disk I/O.
    if (!validPaths[file]) {
      let stat;
      try {
        stat = fs.statSync(file);
      } catch (e) {
        throw new TypeError(`Slave constructor argument #0 requires a regular file, but received error: ${e.message}`);
      }

      if (!stat.isFile()) {
        throw new TypeError(`Slave constructor argument #0 requires a regular file, but ${file} isn't a file.`);
      } else {
        validPaths[file] = true;
      }
    }

    /**
     * Options for this slave instance.
     * @namespace SlaveOptions
     * @type {Object}
     */
    this[settings] = {
      /**
       * The numeric slave id assigned to this slave.
       * @type {Number}
       */
      id: slaveIds++,

      /**
       * An optional alias assigned to the
       * @type {String|null}
       */
      alias: typeof options.alias === 'string' ? options.alias : this._.uniqueId(),

      /**
       * The filepath to the slave process.
       * @type {String}
       */
      location: file,

      /**
       * True if the child has exited (or closed), false otherwise.
       * @type {Boolean}
       */
      exited: false,

      /**
       * The actual ChildProcess instance this Slave object will create.
       * @type {ChildProcess}
       */
      process: null,

      /**
       * Once set to true, no more messages will be sent to this slave process.
       * This will allow it to exit gracefully.
       * @type {Boolean}
       */
      closed: false,

      /**
       * True if the child failed to spawn, false otherwise.
       * @type {Boolean}
       */
      spawnError: false,

      /**
       * Used by shutdown to signify that the slave can no longer recieve incoming messages.
       * @type {Boolean}
       */
      rejectingRequests: false,

      /**
       * The total number of messages sent by the master process to the slave process.
       * @type {Number}
       */
      sent: 0,

      /**
       * The total number of messages received by the slave process.
       * @type {Number}
       */
      received: 0,

      /**
       * Handles slave exceptions
       * @param {Error} e The slave's error.
       * @return {undefined}
       */
      onUncaughtException: options.onUncaughtException instanceof Function
        ? options.onUncaughtException
        : () => {},

      /**
       * The group this slave belongs to.
       * @type {String}
       */
      group: options.group || 'global',
    };

    slaves._.every((s) => {
      if (s.alias === this[settings].alias) throw new Error(`Slave with alias "${options.alias}" already exists.`);
      return true;
    });

    // Add this slave to the slave store...
    slaves[this.id] = this;

    // Check for a slave options array...
    if (!(options.args instanceof Array)) options.args = [];
    const args = options.args._.clone();

    // Add in some custom cli args...
    args.push(
      `--dist-io-slave-id=${this[settings].id}`,
      `--dist-io-slave-alias=${this[settings].alias}`
    );

    if (typeof options.title === 'string') {
      args.push(`--dist-io-slave-title=${options.title}`);
    }

    // Fork the child process...
    this[settings].process = fork(file, args, options.forkOptions || { stdio: 'pipe' });
    initializeSlaveEventsWithSlaveAndChildProcess(this, this[settings].process, options);
  }

  /**
   * Get's the name of the group the slave belongs to.
   * @return {String} The slave's group name.
   */
  get group() {
    return this[settings].group;
  }

  /**
   * The number of messages the master has sent to the slave process.
   * @return {Number} The total sent messages.
   */
  get sent() {
    return this[settings].sent;
  }

  /**
   * The number of messages the master has received from the slave process.
   * @return {Number} The total received messages.
   */
  get received() {
    return this[settings].sent;
  }

  /**
   * Sets the group this slave belongs to.
   * @param {String} g The name of the new group for this slave.
   */
  set group(g) {
    if (typeof g === 'string') this[settings].group = g;
  }

  /**
   * Returns the slave's id.
   * @return {Number} The slave's id.
   */
  get id() {
    return this[settings].id;
  }

  /**
   * The slave's process id.
   * @return {Number} The slave's PID.
   */
  get pid() {
    return this[settings].process.pid;
  }

  /**
   * Alias for the slave's id.
   * @return {Number} The slave's id.
   */
  get rank() {
    return this[settings].id;
  }

  /**
   * Returns the slave's alias
   * @return {Number} The slave's alias.
   */
  get alias() {
    return this[settings].alias;
  }

  /**
   * Returns the slave's filepath.
   * @return {String} The slave's code path.
   */
  get location() {
    return this[settings].location;
  }

  /**
   * Determines if the slave is not busy (idle)
   * @return {Boolean} True if the slave is idle, false otherwise.
   */
  get isIdle() {
    return this.pendingRequests === 0;
  }

  /**
   * Determines if the slave is busy
   * @return {Boolean} True if the slave is budy, false otherwise.
   */
  get isBusy() {
    return !this.isIdle;
  }

  /**
   * Gets the number of pending request for this slave.
   * @return {Number} The number of pending requests for this slave.
   */
  get pendingRequests() {
    if (pendingRequests[this.id]) {
      return pendingRequests[this.id]._.size();
    }
    return 0;
  }

  /**
   * Returns the connection state of the slave process.
   * @return {Boolean} True if messages can still be sent/received from the child, false otherwise.
   */
  get isConnected() {
    return this[settings].process.connected;
  }

  /**
   * Returns the process run state of the child process.
   * @return {Boolean} True if the process is running, false otherwise.
   */
  get hasExited() {
    return this[settings].exited;
  }

  /**
   * Returns the spawn error, if one occured.
   * @return {Error|null} The error that was recieved during spawn, if any.
   */
  get spawnError() {
    return this[settings].spawnError || null;
  }

  /**
   * The function to invoke if the child throws an exception.
   * @param {Function} f A callback function.
   * @return {undefined}
   */
  set onUncaughtException(f) {
    if (typeof f === 'function') this[settings].onUncaughtException = f;
  }

  /**
   * Allows us to chain promises against instantation of a Slave object.
   * @param {Function} cb The callback to invoke.
   * @return {Promise} A promise for completion.
   */
  then(cb) {
    if (cb instanceof Function) {
      const res = cb.call(this, this);
      if (res instanceof Promise) return res;
      return new Promise(resolve => {
        resolve(res);
      });
    }
    return new Promise(resolve => {
      resolve();
    });
  }

  /**
   * A string representation of this object.
   * @return {String} The string representation of this Slave object.
   */
  toString() {
    return `Slave id=${this[settings].id}, ` +
           `alias=${this[settings].alias}, ` +
           `sent=${this[settings].sent}, ` +
           `received=${this[settings].received}`;
  }

  /**
   * Sends an acknowledgment to the slave.
   * @param {Object=} meta Meta data to send to the slave along with this acknowledgment.
   * @return {Promise} A promise for completion.
   */
  ack(meta) {
    return this.exec(Commands.ACK, null, typeof meta === 'object' &amp;&amp; meta ? meta : { timeout: 10000 });
  }

  /**
   * Sends an noop command to the slave.
   * @param {Object=} meta Meta data to send to the slave along with this acknowledgment.
   * @return {Promise} A promise for completion.
   */
  noop(meta) {
    return this.exec(Commands.NULL, null, typeof meta === 'object' &amp;&amp; meta ? meta : { timeout: 10000 });
  }

  /**
   * Forcefully kills the slave process.
   * @param {String=} signal The signal to kill the slave with.
   * @return {Slave} The current Slave instance.
   */
  kill(signal) {
    if (!this[settings].spawnError &amp;&amp; !this[settings].exited) {
      this[settings].process.kill(signal || 'SIGKILL');
      cleanupSlaveReferences(this);
      /**
       * @event killed
       * @argument {String} signal The signal sent to kill the slave.
       * Triggered when the slave is killed (or a singal is sent to it).
       */
      this.emit('killed', signal || 'SIGKILL');

      /**
       * Emitted when slave interaction is no longer possible.
       * @event exited
       */
      this.emit('exited');
    }
    return this;
  }

  /**
   * Gracefully shuts down the child process.
   * @param {Function=} done A callback for completion.
   * @return {Promise} A promise for completion.
   */
  close(...args) {
    const done = args._.getCallback();
    return new Promise((resolve, reject) => {
      if (!this[settings].spawnError &amp;&amp; !this[settings].exited &amp;&amp; !this[settings].closed) {
        this[settings].closed = true;
        sendCommandMessageToChildWithMetadata(Commands.EXIT, this, null, null, response => {
          this[settings].gotExitResponse = true;
          cleanupSlaveReferences(this);

          /**
           * @event closed
           * @property {Error|null} err An error, if one occured during close.
           * @property {String} status The close status sent by the slave.
           * Triggered when the slave is closed.
           */
          this.emit('closed', response.error, response.value);
          this.emit('exited');

          done.call(this, response.error, response.value);
          return response.error ? reject(response.error) : resolve(response.value);
        });
      } else {
        resolve(true);
      }
    });
  }

  /**
   * Gracefully shuts down the slave, after all remaning messages are received.
   * @param {Function=} done A callback for completion.
   * @return {Promise} A promise for completion.
   */
  shutdown(...args) {
    const done = args._.getCallback();
    this[settings].rejectingRequests = true;
    delete slaves[this.id];

    if (!pendingRequests[this.id] || pendingRequests[this.id]._.size() === 0) return this.close(done);

    /**
     * Emitted when the slave is scheduled for shutdown.
     * @event shutting-down
     * @argument {Slave} slave The slave.
     * @argument {...*} args The arguments passed to shutdown
     */
    this.emit('shutdown', this, ...args);
    return new Promise((resolve, reject) => {
      this.on('response', () => {
        if (pendingRequests[this.id]._.size() === 0) {
          this.close()
            .then(status => {
              done.call(this, null, status);
              resolve(status);
            })
            .catch(e => {
              done.call(this, e, null);
              reject(e);
            });
        }
      });
    });
  }

  /**
   * Alias for Slave#close.
   * @param {...*} args Arguments to send to Slave#close
   * @return {Promise} A promise for completion.
   */
  exit(...args) {
    return this.close(...args);
  }

  /**
   * Sends a command to the slave to execute...
   * @param {String} command The command for the slave to execute
   * @param {Object|String|Number|Boolean|Array|null} data The data to send to the slave.
   * @param {Object=} metadata "Options" to send to the slave.
   * @return {Promise} A promise for completion.
   */
  exec(command, data, metadata) {
    const done = arguments._.getCallback(); // eslint-disable-line prefer-rest-params
    const meta = typeof metadata === 'object' ? metadata : {};

    if (data instanceof Function) data = null;

    return new Promise((resolve, reject) => {
      // Check to make sure the slave hasn't exited, or that it didn't spawn.
      if (canInteract(this)) {
        if (typeof command !== 'string' &amp;&amp; typeof command !== 'symbol') {
          if (typeof command === 'number') {
            // Convert the command to a string...
            command = command.toString();
          } else {
            // Bad command, resolve with error...
            const err = new TypeError(
              `Slave#exec expected argument #0 to be a command string, but got: ${typeof command}`
            );

            reject(err);
            done.call(this, err, null);
            return;
          }
        }

        // Send the message to the slave process...
        sendCommandMessageToChildWithMetadata(command, this, meta, data,
          // Invoked when the message is received, or times out if the meta.timeout property is set.
          (response, request) => {
            this[settings].received++;

            /**
             * Emitted everytime the slave receives a response to a request.
             * @event response
             * @argument {Response} request The resposne from the request.
             * @argument {Request} request The request object originally sent to the slave.
             */
            this.emit('response', response, request);

            resolve(response);
            done.call(response, null, response, request);
          });
      } else { // The slave has been shutdown, reject with error...
        const err = new Error(`${this.toString()} has been shutdown, closed, or killed.`);
        reject(err);
        done.call(this, err, null, this);
      }
    });
  }

  /**
   * An alias for Slave#exec
   * @param {...*} Arguments to pass to Slave#exec
   * @return {Promise} A promise for completion.
   */
  do(...args) {
    return this.exec(...args);
  }
}

/**
 * The Slave class.
 * @type {Slave}
 */
module.exports = Slave;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Mon Jun 06 2016 22:34:27 GMT-0400 (EDT) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
